### Processes

 - **Processes** are programs / applications running in the computer's memory.
 - Conceptually, each Process consists of the following regions:
	 - **Stack**: Stored temporary data (i.e., function parameters, return addresses, local variables, etc.)
	 - **Heap**: Used for dynamic memory allocation during run time.
	 - **Data**: Stores global/static variables.
	 - **Text**: Stores program code.
 - The **Stack** and the **Heap** can expand.

### States

 - Processes have a 'lifecycle', consisting of various **States**. State information stored in **Process Control Block (PCB)**.

![[Pasted image 20260131143355.png]]

 - **New**: Process is created.
 - **Ready**: Process waiting to be assigned to CPU.
 - **Running**: Instructions are being executed.
 - **Waiting/Blocked**: Process waiting on Event to occur.
 - **Exit**: Process finishes execution.

### Context Switch

 - CPU swaps between running Processes.
 - OS stops the current executing Process:
	 - Saves (Running) **State** to **PCB** (Process when 'Waiting')
	 - Loads (Waiting) Process (from PCB), 'Ready' > 'Running'
 - Whilst **Context Switching** occurs, CPU/OS processing limited in what other operations it can perform (so Context Switch Management is important)

### Processes

 - Modern OS will have several (1, 2, 100's) of processes running concurrently.
 - Many Processes (2+) may need to access same shared resources (typically RAM)
 - If access is not co-ordinated, can lead to various problems.

 - **Example**
	 - Two current Processes (Threads) performing action on a shared variable.
	 - i.e., increment / decrement a counter variable (`i`).
 - What will the value of `i` be.
 - Temporal - Depends on which Process / Thread is modifying `i` at a given snapshot in time.
 - Leading to **unpredictable behaviour**.

### Processes - 'Unpredictable Behaviour'

 - Terms related to this '**unpredictable behaviour**', include:
	 - **Race Condition**: When multiple Processes (or threads) attempt to read/write to the same (shared) resource, end result depends on execution speed/timing of individual Processes.
	 - **Critical Region**: The section of code (within a Process) that is responsible for reading/writing to shared resources. Processes should have exclusive access, whilst executing Critical Region.

### Synchronisation

 - In theory, the solution to 'unpredictable behaviour' is **Synchronisation**:
	 - i.e., the Managing/Scheduling/Ordering Processes to shared resoureces.
 - Easiest way, is to provide exclusive access (to a shared resource) to each Process, one at a time.
- i.e., prevent the '**Race**' (condition), by allowing only one process at a time, to execute it's '**Critical Region**'.
 - There are various ways to synchronise processes, mainly co-ordinating how Processes communicate with each other.
 - Communication between Processes ('**Inter Process Communication**') can be **Direct** (for reference) and **Indirect** (more common).
 - **Indirect Communication**:
	 - Shared Memory (Recap from previous lecture)
		 - Signals
		 - Semaphores
		 - Pipes
		 - Sockets

### Direct Communication

 - In this form of IPC, Processes directly communicate with each other
 - In code form, Processes support messages between each other via Send/Receive methods.
 - i.e.,
	 - `ProcessA` sends a message to `ProcessB`, via `Send()`.
	 - `ProcessB` receives via `Receive()`.
 - Major disadvantage of Direct Communication:
	 - Developer needs to know Process ID's in advance.
	 - Process ID's will potentially need to be 'hard coded' into program code.
 - Hence, Indirect Communication being more prevalent within IPC.

### Indirect Communication

 - As the name suggests, allows processes to communicate *indirectly* via a third part storage/memory area.
 - Communicating Processes read/write to agreed area, but never communicate with each other directly.
 - This access needs to be managed or synchronised.

### Shared Memory

 - Processes share a region of memory (**Region Table**)
 - Permission modes, Size and Pointer (to an entry in the Region Table) are stored in a **Shared Memory Table**.
 - **Region Table** 'attached' to the processes involved in the IPC (**Process Table**), after which, processes can read/write to the shared memory.

 - **Advantages**
	 - Fastest IPC method (Read/Write to Memory Location)
 - **Disadvantages**
	 - Programmer (of Shared Memory implementation) needs to code **mutual exclusion**.

### Signals

- Could be considered software based interrupts (Events? HW Interrupts?)
- Interrupts generated by (process) errors, Keyboard/Mouse events etc.
- Signals can also be used as a way of communicating with other processes.
- Signals can be classified/grouped accordingly:
	- Signals generated at Process Termination.
	- Signals generated due to process exceptions, i.e., process attempts to write to Read Only memory.
	- Signals generated as a result of major OS exception, i.e., running out of system resources.
	- Signals generated by tracing process execution (i.e., in Linux `ptrace()`).

